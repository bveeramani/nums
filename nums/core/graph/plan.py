from nums.core.compute.compute_manager import ComputeManager


class AlgebraicOp(object):

    def __init__(self, opid, name, opidargs, kwargs, syskwargs):
        self.opid = opid
        self.name = name
        self.opidargs = opidargs
        self.kwargs = kwargs
        self.syskwargs = syskwargs

    def call(self, cm: ComputeManager, idmap: dict):
        oids = [idmap[opid] for opid in self.opidargs]
        return cm.call(self.name, *oids, kwargs=self.kwargs, syskwargs=self.syskwargs)


class TensorDot(AlgebraicOp):
    pass


class ElementwiseOp(AlgebraicOp):
    pass


class FusedOp(ElementwiseOp):
    # Fused ops are custom registered ops.
    # name passed here will be some custom registered expression,
    # but it should still work the same way.
    pass


class Plan(object):
    # Plan generated from a computation graph.
    # For each entry in a GraphArray, we'll have an associated Plan instance.
    # The final oid generated by the Plan instance is the oid associated
    # with the output of the corresponding GraphArray entry.
    def __init__(self, cm: ComputeManager, init_idmap: dict):
        self.cm = cm
        self.ops = []
        # dict from opid to oid.
        self.idmap = init_idmap

    def append(self, op: AlgebraicOp):
        self.ops.append(op)

    def execute(self):
        for op in self.ops:
            op: AlgebraicOp = op
            oid = op.call(self.cm, self.idmap)
            self.idmap[op.opid] = oid
